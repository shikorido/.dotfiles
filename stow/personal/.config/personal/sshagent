#!/usr/bin/env bash

# Works ideal in case when "ps -ef" shows everything.
# However, under termux user we cannot trust "ps -ef".
#
# We can rely on ssh-add output or return code 2 in case of broken socket:
#  Error connecting to agent: No such file or directory
#  Error connecting to agent: Connection refused
# But we should not consider the following as an error:
#  The agent has no identities. (err code 1)
# We lack the possibility to get SSH_AGENT_PID in that case.
#
# UPD1. The following error arises when we probe socket from previous runs:
#  Could not open a connection to your authentication agent.
# So using "pkg i termux-services" (depends on runit) and "sv-enable ssh-agent" is the only way without root?
# I will handle this case first.
# UPD2. Being root under termux still leads to broken socket as stated above.
# UPD3. I was wrong. The issue concluded in "ssh-add" usage without exported SSH_AUTH_SOCK.
#       Now it works fine for termux user and termux root.
#       Termux-services work using the following invocation:
#        $PREFIX/bin/runsvdir $PREFIX/var/service
#       the service directory contains a set of folders that correspond to service name (ssh-agent, sshd, tx11, tx11-xfce4).
#       Indeed we could use ssh-agent service for termux but in that case we must perform
#       chown and restorecon on $PREFIX/var/service/SERVICE_NAME/down (added using sv-disable and removed by sv-enable).
#       I will move ssh-agent folder under $PREFIX/var/service to $PREFIX/var/service_inactive to avoid ssh-agent service listening
#       and two processes that are tied to service life cycle:
#        runsv ssh-agent
#        svlogd -tt /data/data/com.termux/files/usr/var/log/sv/ssh-agent

sshagent() {
	# Termux-services. Make ssh-agent inactive.
	[ -e ~/.zsh_termux ] && [ -O $PREFIX ] && {
		mkdir -p $PREFIX/var/service_inactive
		[ -d "$PREFIX/var/service/ssh-agent" ] && {
			[ -e "$PREFIX/var/service_inactive/ssh-agent" ] && {
				cp -RPu "$PREFIX/var/service/ssh-agent/." "$PREFIX/var/service_inactive/ssh-agent/"
				rm -rf "$PREFIX/var/service/ssh-agent"
			} || mv "$PREFIX/var/service/ssh-agent" "$PREFIX/var/service_inactive/"
		}
	}

	! [ -e ~/.ssh ] && mkdir -p ~/.ssh 2>/dev/null && chmod 700 ~/.ssh

	! [ -d ~/.ssh ] && ! [ -L ~/.ssh ] && echo "$HOME/.ssh is neither a folder nor a symlink, preventing ssh-agent startup." && return

	# "ssh-add -l" approach combined with "ps -ef" to get SSH_AGENT_PID where possible.
	command -v ssh-agent >/dev/null && {
		if [ "$_MSYS2_" = 1 ] && powershell.exe -Command \
		"([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)" |
		grep -q True; then
			export SSH_AUTH_SOCK=~/.ssh/agent.admin.`id -u`
		else
			export SSH_AUTH_SOCK=~/.ssh/agent.`id -u`
		fi

		ssh_agent_state=`ps -ef | grep "ssh-agen"`
		ssh_agent_state=`echo "$ssh_agent_state" | grep "^[[:space:]]*\`id -un\`" | grep "ssh-agent"`
		# Should we also match by socket?
		# If ssh-agent was ran under admin in msys2 the process details are hidden
		# under unelevated user thus we can see only /usr/bin/ssh-agent.
		ssh_agent_state=`echo "$ssh_agent_state" | grep "ssh-agent -a $SSH_AUTH_SOCK"`

		if [ -O "$PREFIX" ]; then
			# Filter out runsv and svlogd in case of termux-services usage (testing).
			ssh_agent_state=`echo "$ssh_agent_state" | grep -v "runsv \|svlogd "`
		fi

		ssh-add -l >/dev/null 2>&1
		[ $? = 2 ] && ssh_agent_socket_alive=0 || ssh_agent_socket_alive=1

		#echo "ssh_agent_state: $ssh_agent_state"
		#echo "ssh_agent_socket_alive: $ssh_agent_socket_alive"

		if [ -n "$ssh_agent_state" ]; then
			SSH_AGENT_PID=`echo "$ssh_agent_state" | awk '{print $2}'`

			#echo "SSH_AGENT_PID extracted: $SSH_AGENT_PID"

			# If muliple agents are open, kill them all.
			if [ "`echo "$SSH_AGENT_PID" | wc -l`" -gt 1 ]; then
				#echo "Line count is greater than 1."
				setopt shwordsplit
				for pid in $SSH_AGENT_PID; do
					kill -9 "$pid"
				done
				setopt noshwordsplit
				[ -S "$SSH_AUTH_SOCK" ] && rm -f "$SSH_AUTH_SOCK"
				eval `ssh-agent -a "$SSH_AUTH_SOCK"` >/dev/null

			# Check if agent holds desired socket.
			elif [ "$ssh_agent_socket_alive" = 1 ] && echo "$ssh_agent_state" | grep -q "$SSH_AUTH_SOCK"; then
				export SSH_AUTH_SOCK
				export SSH_AGENT_PID
			else
				kill "$SSH_AGENT_PID"
				[ -S "$SSH_AUTH_SOCK" ] && rm -f "$SSH_AUTH_SOCK"
				eval `ssh-agent -a "$SSH_AUTH_SOCK"` >/dev/null
			fi
		else
			if [ "$ssh_agent_socket_alive" = 1 ]; then
				export SSH_AUTH_SOCK
				unset SSH_AGENT_PID
				#[ -n "$SSH_AGENT_PID" ] && export SSH_AGENT_PID
			else
				# sleep is required by WSL in some cases to correctly handle socket removal.
				[ -S "$SSH_AUTH_SOCK" ] && rm -f "$SSH_AUTH_SOCK"
				if [ "$_WSL_" = 1 ]; then
					ssh_agent_try=0
					ssh_agent_try_limit=10
					until [ "$ssh_agent_try" -gt "$ssh_agent_try_limit" ]; do
						sleep 2
						ssh_agent_eval=`ssh-agent -a "$SSH_AUTH_SOCK" 2>/dev/null`
						[ $? -eq 0 ] && ssh_agent_success=1 && eval "$ssh_agent_eval" >/dev/null && break
						ssh_agent_try=$(( ssh_agent_try + 1 ))
						#echo "ssh-agent failed to run. Attempt $ssh_agent_try"
						#ls -al "$SSH_AUTH_SOCK"
						rm -f "$SSH_AUTH_SOCK"
					done
					! [ "$ssh_agent_success" = 1 ] && echo "Could not start ssh-agent in WSL after $ssh_agent_try_limit retries with 2s interval."
					unset ssh_agent_try ssh_agent_try_limit ssh_agent_eval ssh_agent_success
				else
					eval `ssh-agent -a "$SSH_AUTH_SOCK"` >/dev/null
				fi
			fi
		fi

		unset ssh_agent_state
		unset ssh_agent_socket_alive
	}
}

# Lazy startup.
find ~/.ssh/ -name "*.pub" >/dev/null 2>&1 || return

sshagent


# Termux-services approach.
#[ -e ~/.zsh_termux ] && [ -O $PREFIX ] && {
# Root user can use it too. But $PREFIX/var/service/SERVICE_NAME/down ownership must be handled.
#[ -e ~/.zsh_termux ] && {
#    # Termux user
#    # Can be overriden via separate run script under $PREFIX/etc/ssh/start_agent.sh
#    # but lets stick to the default one.
#    export SSH_AUTH_SOCK=$PREFIX/var/run/ssh-agent.socket
#    ssh-add -l >/dev/null 2>&1
#    if [ $? = 2 ]; then
#        # Broken socket or ssh-agent is not running.
#        sv-disable ssh-agent
#        sv-enable ssh-agent
#    fi
#    # Second check can be used to alarm that ssh-agent is not working.
#    #export SSH_AUTH_SOCK
#    return
#}


# "ps -ef" approach
#
#command -v ssh-agent >/dev/null && {
#    find ~/.ssh/ -name "*.pub" >/dev/null 2>&1 || return
#
#    SSH_AUTH_SOCK=~/.ssh/agent.$UID
#    ssh_agent_state=`ps -ef | grep "ssh-agen"`
#    ssh_agent_state=`echo "$ssh_agent_state" | grep "^[[:space:]]*$USER" | grep "ssh-agent"`
#
#    if [ -n "$ssh_agent_state" ]; then
#        SSH_AGENT_PID=`echo "$ssh_agent_state" | awk '{print $2}'`
#
#        # Check if agent holds desired socket.
#        if echo "$ssh_agent_state" | grep -q "$SOCKET"; then
#            export SSH_AUTH_SOCK
#            export SSH_AGENT_PID
#        else
#            kill "$SSH_AGENT_PID"
#            [ -S "$SSH_AUTH_SOCK" ] && rm -f "$SSH_AUTH_SOCK"
#            eval `ssh-agent -a "$SSH_AUTH_SOCK"` >/dev/null
#        fi
#    else
#        [ -S "$SSH_AUTH_SOCK" ] && rm -f "$SSH_AUTH_SOCK"
#        eval `ssh-agent -a "$SSH_AUTH_SOCK"` >/dev/null
#    fi
#
#    unset ssh_agent_state
#}

